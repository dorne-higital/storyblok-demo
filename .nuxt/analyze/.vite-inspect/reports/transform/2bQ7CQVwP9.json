{
  "resolvedId": "/Users/danielhorne/Desktop/Business/websites/Github/storyblok-demo/node_modules/@storyblok/vue/dist/storyblok-vue.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { defineComponent as A, ref as _, resolveDynamicComponent as $, inject as N, openBlock as L, createBlock as M, mergeProps as F, onMounted as z, defineAsyncComponent as U } from \"vue\";\nlet j = !1;\nconst x = [], H = (i) => new Promise((e, t) => {\n  if (typeof window > \"u\" || (window.storyblokRegisterEvent = (r) => {\n    if (window.location === window.parent.location) {\n      console.warn(\"You are not in Draft Mode or in the Visual Editor.\");\n      return;\n    }\n    j ? r() : x.push(r);\n  }, document.getElementById(\"storyblok-javascript-bridge\")))\n    return;\n  const s = document.createElement(\"script\");\n  s.async = !0, s.src = i, s.id = \"storyblok-javascript-bridge\", s.onerror = (r) => t(r), s.onload = (r) => {\n    x.forEach((o) => o()), j = !0, e(r);\n  }, document.getElementsByTagName(\"head\")[0].appendChild(s);\n});\nvar q = Object.defineProperty, V = (i, e, t) => e in i ? q(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, h = (i, e, t) => (V(i, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nfunction C(i) {\n  return !(i !== i || i === 1 / 0 || i === -1 / 0);\n}\nfunction D(i, e, t) {\n  if (!C(e))\n    throw new TypeError(\"Expected `limit` to be a finite number\");\n  if (!C(t))\n    throw new TypeError(\"Expected `interval` to be a finite number\");\n  const s = [];\n  let r = [], o = 0;\n  const n = function() {\n    o++;\n    const a = setTimeout(function() {\n      o--, s.length > 0 && n(), r = r.filter(function(u) {\n        return u !== a;\n      });\n    }, t);\n    r.indexOf(a) < 0 && r.push(a);\n    const c = s.shift();\n    c.resolve(i.apply(c.self, c.args));\n  }, l = function(...a) {\n    const c = this;\n    return new Promise(function(u, p) {\n      s.push({\n        resolve: u,\n        reject: p,\n        args: a,\n        self: c\n      }), o < e && n();\n    });\n  };\n  return l.abort = function() {\n    r.forEach(clearTimeout), r = [], s.forEach(function(a) {\n      a.reject(function() {\n        Error.call(this, \"Throttled function aborted\"), this.name = \"AbortError\";\n      });\n    }), s.length = 0;\n  }, l;\n}\nclass k {\n  constructor() {\n    h(this, \"isCDNUrl\", (e = \"\") => e.indexOf(\"/cdn/\") > -1), h(this, \"getOptionsPage\", (e, t = 25, s = 1) => ({\n      ...e,\n      per_page: t,\n      page: s\n    })), h(this, \"delay\", (e) => new Promise((t) => setTimeout(t, e))), h(this, \"arrayFrom\", (e = 0, t) => [...Array(e)].map(t)), h(this, \"range\", (e = 0, t = e) => {\n      const s = Math.abs(t - e) || 0, r = e < t ? 1 : -1;\n      return this.arrayFrom(s, (o, n) => n * r + e);\n    }), h(this, \"asyncMap\", async (e, t) => Promise.all(e.map(t))), h(this, \"flatMap\", (e = [], t) => e.map(t).reduce((s, r) => [...s, ...r], [])), h(this, \"escapeHTML\", function(e) {\n      const t = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n      }, s = /[&<>\"']/g, r = RegExp(s.source);\n      return e && r.test(e) ? e.replace(s, (o) => t[o]) : e;\n    });\n  }\n  /**\n   * @method stringify\n   * @param  {Object} params\n   * @param  {String} prefix\n   * @param  {Boolean} isArray\n   * @return {String} Stringified object\n   */\n  stringify(e, t, s) {\n    const r = [];\n    for (const o in e) {\n      if (!Object.prototype.hasOwnProperty.call(e, o))\n        continue;\n      const n = e[o], l = s ? \"\" : encodeURIComponent(o);\n      let a;\n      typeof n == \"object\" ? a = this.stringify(\n        n,\n        t ? t + encodeURIComponent(\"[\" + l + \"]\") : l,\n        Array.isArray(n)\n      ) : a = (t ? t + encodeURIComponent(\"[\" + l + \"]\") : l) + \"=\" + encodeURIComponent(n), r.push(a);\n    }\n    return r.join(\"&\");\n  }\n  /**\n   * @method getRegionURL\n   * @param  {String} regionCode region code, could be eu, us, cn, ap or ca\n   * @return {String} The base URL of the region\n   */\n  getRegionURL(e) {\n    const t = \"api.storyblok.com\", s = \"api-us.storyblok.com\", r = \"app.storyblokchina.cn\", o = \"api-ap.storyblok.com\", n = \"api-ca.storyblok.com\";\n    switch (e) {\n      case \"us\":\n        return s;\n      case \"cn\":\n        return r;\n      case \"ap\":\n        return o;\n      case \"ca\":\n        return n;\n      default:\n        return t;\n    }\n  }\n}\nconst B = function(i, e) {\n  const t = {};\n  for (const s in i) {\n    const r = i[s];\n    e.indexOf(s) > -1 && r !== null && (t[s] = r);\n  }\n  return t;\n}, J = (i) => i === \"email\", K = () => ({\n  singleTag: \"hr\"\n}), Y = () => ({\n  tag: \"blockquote\"\n}), W = () => ({\n  tag: \"ul\"\n}), G = (i) => ({\n  tag: [\n    \"pre\",\n    {\n      tag: \"code\",\n      attrs: i.attrs\n    }\n  ]\n}), Q = () => ({\n  singleTag: \"br\"\n}), X = (i) => ({\n  tag: `h${i.attrs.level}`\n}), Z = (i) => ({\n  singleTag: [\n    {\n      tag: \"img\",\n      attrs: B(i.attrs, [\"src\", \"alt\", \"title\"])\n    }\n  ]\n}), ee = () => ({\n  tag: \"li\"\n}), te = () => ({\n  tag: \"ol\"\n}), se = () => ({\n  tag: \"p\"\n}), re = (i) => ({\n  tag: [\n    {\n      tag: \"span\",\n      attrs: {\n        \"data-type\": \"emoji\",\n        \"data-name\": i.attrs.name,\n        emoji: i.attrs.emoji\n      }\n    }\n  ]\n}), oe = () => ({\n  tag: \"b\"\n}), ie = () => ({\n  tag: \"s\"\n}), ne = () => ({\n  tag: \"u\"\n}), ae = () => ({\n  tag: \"strong\"\n}), le = () => ({\n  tag: \"code\"\n}), ce = () => ({\n  tag: \"i\"\n}), he = (i) => {\n  if (!i.attrs)\n    return {\n      tag: \"\"\n    };\n  const e = new k().escapeHTML, t = { ...i.attrs }, { linktype: s = \"url\" } = i.attrs;\n  if (delete t.linktype, t.href && (t.href = e(i.attrs.href || \"\")), J(s) && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), t.custom) {\n    for (const r in t.custom)\n      t[r] = t.custom[r];\n    delete t.custom;\n  }\n  return {\n    tag: [\n      {\n        tag: \"a\",\n        attrs: t\n      }\n    ]\n  };\n}, ue = (i) => ({\n  tag: [\n    {\n      tag: \"span\",\n      attrs: i.attrs\n    }\n  ]\n}), pe = () => ({\n  tag: \"sub\"\n}), de = () => ({\n  tag: \"sup\"\n}), ge = (i) => ({\n  tag: [\n    {\n      tag: \"span\",\n      attrs: i.attrs\n    }\n  ]\n}), fe = (i) => {\n  var e;\n  return (e = i.attrs) != null && e.color ? {\n    tag: [\n      {\n        tag: \"span\",\n        attrs: {\n          style: `background-color:${i.attrs.color};`\n        }\n      }\n    ]\n  } : {\n    tag: \"\"\n  };\n}, me = (i) => {\n  var e;\n  return (e = i.attrs) != null && e.color ? {\n    tag: [\n      {\n        tag: \"span\",\n        attrs: {\n          style: `color:${i.attrs.color}`\n        }\n      }\n    ]\n  } : {\n    tag: \"\"\n  };\n}, ye = {\n  nodes: {\n    horizontal_rule: K,\n    blockquote: Y,\n    bullet_list: W,\n    code_block: G,\n    hard_break: Q,\n    heading: X,\n    image: Z,\n    list_item: ee,\n    ordered_list: te,\n    paragraph: se,\n    emoji: re\n  },\n  marks: {\n    bold: oe,\n    strike: ie,\n    underline: ne,\n    strong: ae,\n    code: le,\n    italic: ce,\n    link: he,\n    styled: ue,\n    subscript: pe,\n    superscript: de,\n    anchor: ge,\n    highlight: fe,\n    textStyle: me\n  }\n}, be = function(i) {\n  const e = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n  }, t = /[&<>\"']/g, s = RegExp(t.source);\n  return i && s.test(i) ? i.replace(t, (r) => e[r]) : i;\n};\nclass v {\n  constructor(e) {\n    h(this, \"marks\"), h(this, \"nodes\"), e || (e = ye), this.marks = e.marks || [], this.nodes = e.nodes || [];\n  }\n  addNode(e, t) {\n    this.nodes[e] = t;\n  }\n  addMark(e, t) {\n    this.marks[e] = t;\n  }\n  render(e, t = { optimizeImages: !1 }) {\n    if (e && e.content && Array.isArray(e.content)) {\n      let s = \"\";\n      return e.content.forEach((r) => {\n        s += this.renderNode(r);\n      }), t.optimizeImages ? this.optimizeImages(s, t.optimizeImages) : s;\n    }\n    return console.warn(\n      `The render method must receive an Object with a \"content\" field.\n\t\t\tThe \"content\" field must be an array of nodes as the type ISbRichtext.\n\t\t\tISbRichtext:\n\t\t\t\tcontent?: ISbRichtext[]\n\t\t\t\tmarks?: ISbRichtext[]\n\t\t\t\tattrs?: any\n\t\t\t\ttext?: string\n\t\t\t\ttype: string\n\t\t\t\t\n\t\t\t\tExample:\n\t\t\t\t{\n\t\t\t\t\tcontent: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttext: 'Hello World',\n\t\t\t\t\t\t\t\t\ttype: 'text'\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\ttype: 'paragraph'\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\ttype: 'doc'\n\t\t\t\t}`\n    ), \"\";\n  }\n  optimizeImages(e, t) {\n    let s = 0, r = 0, o = \"\", n = \"\";\n    typeof t != \"boolean\" && (typeof t.width == \"number\" && t.width > 0 && (o += `width=\"${t.width}\" `, s = t.width), typeof t.height == \"number\" && t.height > 0 && (o += `height=\"${t.height}\" `, r = t.height), (t.loading === \"lazy\" || t.loading === \"eager\") && (o += `loading=\"${t.loading}\" `), typeof t.class == \"string\" && t.class.length > 0 && (o += `class=\"${t.class}\" `), t.filters && (typeof t.filters.blur == \"number\" && t.filters.blur >= 0 && t.filters.blur <= 100 && (n += `:blur(${t.filters.blur})`), typeof t.filters.brightness == \"number\" && t.filters.brightness >= -100 && t.filters.brightness <= 100 && (n += `:brightness(${t.filters.brightness})`), t.filters.fill && (t.filters.fill.match(/[0-9A-Fa-f]{6}/g) || t.filters.fill === \"transparent\") && (n += `:fill(${t.filters.fill})`), t.filters.format && [\"webp\", \"png\", \"jpeg\"].includes(t.filters.format) && (n += `:format(${t.filters.format})`), typeof t.filters.grayscale == \"boolean\" && t.filters.grayscale && (n += \":grayscale()\"), typeof t.filters.quality == \"number\" && t.filters.quality >= 0 && t.filters.quality <= 100 && (n += `:quality(${t.filters.quality})`), t.filters.rotate && [90, 180, 270].includes(t.filters.rotate) && (n += `:rotate(${t.filters.rotate})`), n.length > 0 && (n = \"/filters\" + n))), o.length > 0 && (e = e.replace(/<img/g, `<img ${o.trim()}`));\n    const l = s > 0 || r > 0 || n.length > 0 ? `${s}x${r}${n}` : \"\";\n    return e = e.replace(\n      /a.storyblok.com\\/f\\/(\\d+)\\/([^.]+)\\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g,\n      `a.storyblok.com/f/$1/$2.$3/m/${l}`\n    ), typeof t != \"boolean\" && (t.sizes || t.srcset) && (e = e.replace(/<img.*?src=[\"|'](.*?)[\"|']/g, (a) => {\n      var c, u;\n      const p = a.match(\n        /a.storyblok.com\\/f\\/(\\d+)\\/([^.]+)\\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g\n      );\n      if (p && p.length > 0) {\n        const g = {\n          srcset: (c = t.srcset) == null ? void 0 : c.map((d) => {\n            if (typeof d == \"number\")\n              return `//${p}/m/${d}x0${n} ${d}w`;\n            if (typeof d == \"object\" && d.length === 2) {\n              let w = 0, S = 0;\n              return typeof d[0] == \"number\" && (w = d[0]), typeof d[1] == \"number\" && (S = d[1]), `//${p}/m/${w}x${S}${n} ${w}w`;\n            }\n          }).join(\", \"),\n          sizes: (u = t.sizes) == null ? void 0 : u.map((d) => d).join(\", \")\n        };\n        let f = \"\";\n        return g.srcset && (f += `srcset=\"${g.srcset}\" `), g.sizes && (f += `sizes=\"${g.sizes}\" `), a.replace(/<img/g, `<img ${f.trim()}`);\n      }\n      return a;\n    })), e;\n  }\n  renderNode(e) {\n    const t = [];\n    e.marks && e.marks.forEach((r) => {\n      const o = this.getMatchingMark(r);\n      o && o.tag !== \"\" && t.push(this.renderOpeningTag(o.tag));\n    });\n    const s = this.getMatchingNode(e);\n    return s && s.tag && t.push(this.renderOpeningTag(s.tag)), e.content ? e.content.forEach((r) => {\n      t.push(this.renderNode(r));\n    }) : e.text ? t.push(be(e.text)) : s && s.singleTag ? t.push(this.renderTag(s.singleTag, \" /\")) : s && s.html ? t.push(s.html) : e.type === \"emoji\" && t.push(this.renderEmoji(e)), s && s.tag && t.push(this.renderClosingTag(s.tag)), e.marks && e.marks.slice(0).reverse().forEach((r) => {\n      const o = this.getMatchingMark(r);\n      o && o.tag !== \"\" && t.push(this.renderClosingTag(o.tag));\n    }), t.join(\"\");\n  }\n  renderTag(e, t) {\n    return e.constructor === String ? `<${e}${t}>` : e.map((s) => {\n      if (s.constructor === String)\n        return `<${s}${t}>`;\n      {\n        let r = `<${s.tag}`;\n        if (s.attrs)\n          for (const o in s.attrs) {\n            const n = s.attrs[o];\n            n !== null && (r += ` ${o}=\"${n}\"`);\n          }\n        return `${r}${t}>`;\n      }\n    }).join(\"\");\n  }\n  renderOpeningTag(e) {\n    return this.renderTag(e, \"\");\n  }\n  renderClosingTag(e) {\n    return e.constructor === String ? `</${e}>` : e.slice(0).reverse().map((t) => t.constructor === String ? `</${t}>` : `</${t.tag}>`).join(\"\");\n  }\n  getMatchingNode(e) {\n    const t = this.nodes[e.type];\n    if (typeof t == \"function\")\n      return t(e);\n  }\n  getMatchingMark(e) {\n    const t = this.marks[e.type];\n    if (typeof t == \"function\")\n      return t(e);\n  }\n  renderEmoji(e) {\n    if (e.attrs.emoji)\n      return e.attrs.emoji;\n    const t = [\n      {\n        tag: \"img\",\n        attrs: {\n          src: e.attrs.fallbackImage,\n          draggable: \"false\",\n          loading: \"lazy\",\n          align: \"absmiddle\"\n        }\n      }\n    ];\n    return this.renderTag(t, \" /\");\n  }\n}\nclass ke {\n  constructor(e) {\n    h(this, \"baseURL\"), h(this, \"timeout\"), h(this, \"headers\"), h(this, \"responseInterceptor\"), h(this, \"fetch\"), h(this, \"ejectInterceptor\"), h(this, \"url\"), h(this, \"parameters\"), h(this, \"fetchOptions\"), this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = \"\", this.parameters = {}, this.fetchOptions = {};\n  }\n  /**\n   *\n   * @param url string\n   * @param params ISbStoriesParams\n   * @returns Promise<ISbResponse | Error>\n   */\n  get(e, t) {\n    return this.url = e, this.parameters = t, this._methodHandler(\"get\");\n  }\n  post(e, t) {\n    return this.url = e, this.parameters = t, this._methodHandler(\"post\");\n  }\n  put(e, t) {\n    return this.url = e, this.parameters = t, this._methodHandler(\"put\");\n  }\n  delete(e, t) {\n    return this.url = e, this.parameters = t, this._methodHandler(\"delete\");\n  }\n  async _responseHandler(e) {\n    const t = [], s = {\n      data: {},\n      headers: {},\n      status: 0,\n      statusText: \"\"\n    };\n    e.status !== 204 && await e.json().then((r) => {\n      s.data = r;\n    });\n    for (const r of e.headers.entries())\n      t[r[0]] = r[1];\n    return s.headers = { ...t }, s.status = e.status, s.statusText = e.statusText, s;\n  }\n  async _methodHandler(e) {\n    let t = `${this.baseURL}${this.url}`, s = null;\n    if (e === \"get\") {\n      const a = new k();\n      t = `${this.baseURL}${this.url}?${a.stringify(\n        this.parameters\n      )}`;\n    } else\n      s = JSON.stringify(this.parameters);\n    const r = new URL(t), o = new AbortController(), { signal: n } = o;\n    let l;\n    this.timeout && (l = setTimeout(() => o.abort(), this.timeout));\n    try {\n      const a = await this.fetch(`${r}`, {\n        method: e,\n        headers: this.headers,\n        body: s,\n        signal: n,\n        ...this.fetchOptions\n      });\n      this.timeout && clearTimeout(l);\n      const c = await this._responseHandler(\n        a\n      );\n      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(c)) : this._statusHandler(c);\n    } catch (a) {\n      return {\n        message: a\n      };\n    }\n  }\n  setFetchOptions(e = {}) {\n    Object.keys(e).length > 0 && \"method\" in e && delete e.method, this.fetchOptions = { ...e };\n  }\n  eject() {\n    this.ejectInterceptor = !0;\n  }\n  _statusHandler(e) {\n    const t = /20[0-6]/g;\n    return new Promise((s, r) => {\n      if (t.test(`${e.status}`))\n        return s(e);\n      const o = {\n        message: e.statusText,\n        status: e.status,\n        response: Array.isArray(e.data) ? e.data[0] : e.data.error || e.data.slug\n      };\n      r(o);\n    });\n  }\n}\nconst P = \"SB-Agent\", R = {\n  defaultAgentName: \"SB-JS-CLIENT\",\n  defaultAgentVersion: \"SB-Agent-Version\",\n  packageVersion: \"6.0.0\"\n};\nlet b = {};\nconst m = {};\nclass ve {\n  /**\n   *\n   * @param config ISbConfig interface\n   * @param endpoint string, optional\n   */\n  constructor(e, t) {\n    h(this, \"client\"), h(this, \"maxRetries\"), h(this, \"throttle\"), h(this, \"accessToken\"), h(this, \"cache\"), h(this, \"helpers\"), h(this, \"resolveCounter\"), h(this, \"relations\"), h(this, \"links\"), h(this, \"richTextResolver\"), h(this, \"resolveNestedRelations\"), h(this, \"stringifiedStoriesCache\");\n    let s = e.endpoint || t;\n    if (!s) {\n      const n = new k().getRegionURL, l = e.https === !1 ? \"http\" : \"https\";\n      e.oauthToken ? s = `${l}://${n(e.region)}/v1` : s = `${l}://${n(e.region)}/v2`;\n    }\n    const r = new Headers();\n    if (r.set(\"Content-Type\", \"application/json\"), r.set(\"Accept\", \"application/json\"), e.headers)\n      for (const n in e.headers)\n        r.set(n, e.headers[n]);\n    r.has(P) || (r.set(P, R.defaultAgentName), r.set(\n      R.defaultAgentVersion,\n      R.packageVersion\n    ));\n    let o = 5;\n    e.oauthToken && (r.set(\"Authorization\", e.oauthToken), o = 3), e.rateLimit && (o = e.rateLimit), e.richTextSchema ? this.richTextResolver = new v(e.richTextSchema) : this.richTextResolver = new v(), e.componentResolver && this.setComponentResolver(e.componentResolver), this.maxRetries = e.maxRetries || 5, this.throttle = D(this.throttledRequest, o, 1e3), this.accessToken = e.accessToken || \"\", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: \"manual\" }, this.helpers = new k(), this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.client = new ke({\n      baseURL: s,\n      timeout: e.timeout || 0,\n      headers: r,\n      responseInterceptor: e.responseInterceptor,\n      fetch: e.fetch\n    });\n  }\n  setComponentResolver(e) {\n    this.richTextResolver.addNode(\"blok\", (t) => {\n      let s = \"\";\n      return t.attrs.body && t.attrs.body.forEach((r) => {\n        s += e(r.component, r);\n      }), {\n        html: s\n      };\n    });\n  }\n  parseParams(e) {\n    return e.token || (e.token = this.getToken()), e.cv || (e.cv = m[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(\",\")), typeof e.resolve_relations < \"u\" && (e.resolve_level = 2), e;\n  }\n  factoryParamOptions(e, t) {\n    return this.helpers.isCDNUrl(e) ? this.parseParams(t) : t;\n  }\n  makeRequest(e, t, s, r) {\n    const o = this.factoryParamOptions(\n      e,\n      this.helpers.getOptionsPage(t, s, r)\n    );\n    return this.cacheResponse(e, o);\n  }\n  get(e, t, s) {\n    t || (t = {});\n    const r = `/${e}`, o = this.factoryParamOptions(r, t);\n    return this.client.setFetchOptions(s), this.cacheResponse(r, o);\n  }\n  async getAll(e, t, s, r) {\n    const o = (t == null ? void 0 : t.per_page) || 25, n = `/${e}`, l = n.split(\"/\"), a = s || l[l.length - 1], c = 1, u = await this.makeRequest(n, t, o, c), p = u.total ? Math.ceil(u.total / o) : 1;\n    this.client.setFetchOptions(r);\n    const g = await this.helpers.asyncMap(\n      this.helpers.range(c, p),\n      (f) => this.makeRequest(n, t, o, f + 1)\n    );\n    return this.helpers.flatMap(\n      [u, ...g],\n      (f) => Object.values(f.data[a])\n    );\n  }\n  post(e, t, s) {\n    const r = `/${e}`;\n    return this.client.setFetchOptions(s), Promise.resolve(this.throttle(\"post\", r, t));\n  }\n  put(e, t, s) {\n    const r = `/${e}`;\n    return this.client.setFetchOptions(s), Promise.resolve(this.throttle(\"put\", r, t));\n  }\n  delete(e, t, s) {\n    const r = `/${e}`;\n    return this.client.setFetchOptions(s), Promise.resolve(this.throttle(\"delete\", r, t));\n  }\n  getStories(e, t) {\n    return this.client.setFetchOptions(t), this._addResolveLevel(e), this.get(\"cdn/stories\", e);\n  }\n  getStory(e, t, s) {\n    return this.client.setFetchOptions(s), this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t);\n  }\n  getToken() {\n    return this.accessToken;\n  }\n  ejectInterceptor() {\n    this.client.eject();\n  }\n  _addResolveLevel(e) {\n    typeof e.resolve_relations < \"u\" && (e.resolve_level = 2);\n  }\n  _cleanCopy(e) {\n    return JSON.parse(JSON.stringify(e));\n  }\n  _insertLinks(e, t, s) {\n    const r = e[t];\n    r && r.fieldtype == \"multilink\" && r.linktype == \"story\" && typeof r.id == \"string\" && this.links[s][r.id] ? r.story = this._cleanCopy(this.links[s][r.id]) : r && r.linktype === \"story\" && typeof r.uuid == \"string\" && this.links[s][r.uuid] && (r.story = this._cleanCopy(this.links[s][r.uuid]));\n  }\n  /**\n   *\n   * @param resolveId A counter number as a string\n   * @param uuid The uuid of the story\n   * @returns string | object\n   */\n  getStoryReference(e, t) {\n    return this.relations[e][t] ? (this.stringifiedStoriesCache[t] || (this.stringifiedStoriesCache[t] = JSON.stringify(\n      this.relations[e][t]\n    )), JSON.parse(this.stringifiedStoriesCache[t])) : t;\n  }\n  _insertRelations(e, t, s, r) {\n    s.indexOf(`${e.component}.${t}`) > -1 && (typeof e[t] == \"string\" ? e[t] = this.getStoryReference(r, e[t]) : Array.isArray(e[t]) && (e[t] = e[t].map((o) => this.getStoryReference(r, o)).filter(Boolean)));\n  }\n  iterateTree(e, t, s) {\n    const r = (o) => {\n      if (o != null) {\n        if (o.constructor === Array)\n          for (let n = 0; n < o.length; n++)\n            r(o[n]);\n        else if (o.constructor === Object) {\n          if (o._stopResolving)\n            return;\n          for (const n in o)\n            (o.component && o._uid || o.type === \"link\") && (this._insertRelations(\n              o,\n              n,\n              t,\n              s\n            ), this._insertLinks(\n              o,\n              n,\n              s\n            )), r(o[n]);\n        }\n      }\n    };\n    r(e.content);\n  }\n  async resolveLinks(e, t, s) {\n    let r = [];\n    if (e.link_uuids) {\n      const o = e.link_uuids.length, n = [], l = 50;\n      for (let a = 0; a < o; a += l) {\n        const c = Math.min(o, a + l);\n        n.push(e.link_uuids.slice(a, c));\n      }\n      for (let a = 0; a < n.length; a++)\n        (await this.getStories({\n          per_page: l,\n          language: t.language,\n          version: t.version,\n          by_uuids: n[a].join(\",\")\n        })).data.stories.forEach(\n          (c) => {\n            r.push(c);\n          }\n        );\n    } else\n      r = e.links;\n    r.forEach((o) => {\n      this.links[s][o.uuid] = {\n        ...o,\n        _stopResolving: !0\n      };\n    });\n  }\n  async resolveRelations(e, t, s) {\n    let r = [];\n    if (e.rel_uuids) {\n      const o = e.rel_uuids.length, n = [], l = 50;\n      for (let a = 0; a < o; a += l) {\n        const c = Math.min(o, a + l);\n        n.push(e.rel_uuids.slice(a, c));\n      }\n      for (let a = 0; a < n.length; a++)\n        (await this.getStories({\n          per_page: l,\n          language: t.language,\n          version: t.version,\n          by_uuids: n[a].join(\",\"),\n          excluding_fields: t.excluding_fields\n        })).data.stories.forEach((c) => {\n          r.push(c);\n        });\n    } else\n      r = e.rels;\n    r && r.length > 0 && r.forEach((o) => {\n      this.relations[s][o.uuid] = {\n        ...o,\n        _stopResolving: !0\n      };\n    });\n  }\n  /**\n   *\n   * @param responseData\n   * @param params\n   * @param resolveId\n   * @description Resolves the relations and links of the stories\n   * @returns Promise<void>\n   *\n   */\n  async resolveStories(e, t, s) {\n    var r, o;\n    let n = [];\n    if (this.links[s] = {}, this.relations[s] = {}, typeof t.resolve_relations < \"u\" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == \"string\" && (n = t.resolve_relations.split(\",\")), await this.resolveRelations(e, t, s)), t.resolve_links && [\"1\", \"story\", \"url\", \"link\"].indexOf(t.resolve_links) > -1 && ((r = e.links) != null && r.length || (o = e.link_uuids) != null && o.length) && await this.resolveLinks(e, t, s), this.resolveNestedRelations)\n      for (const l in this.relations[s])\n        this.iterateTree(\n          this.relations[s][l],\n          n,\n          s\n        );\n    e.story ? this.iterateTree(e.story, n, s) : e.stories.forEach((l) => {\n      this.iterateTree(l, n, s);\n    }), this.stringifiedStoriesCache = {}, delete this.links[s], delete this.relations[s];\n  }\n  async cacheResponse(e, t, s) {\n    (typeof s > \"u\" || !s) && (s = 0);\n    const r = this.helpers.stringify({ url: e, params: t }), o = this.cacheProvider();\n    if (this.cache.clear === \"auto\" && t.version === \"draft\" && await this.flushCache(), t.version === \"published\" && e != \"/cdn/spaces/me\") {\n      const n = await o.get(r);\n      if (n)\n        return Promise.resolve(n);\n    }\n    return new Promise(async (n, l) => {\n      var a;\n      try {\n        const c = await this.throttle(\"get\", e, t);\n        if (c.status !== 200)\n          return l(c);\n        let u = { data: c.data, headers: c.headers };\n        if ((a = c.headers) != null && a[\"per-page\"] && (u = Object.assign({}, u, {\n          perPage: c.headers[\"per-page\"] ? parseInt(c.headers[\"per-page\"]) : 0,\n          total: c.headers[\"per-page\"] ? parseInt(c.headers.total) : 0\n        })), u.data.story || u.data.stories) {\n          const p = this.resolveCounter = ++this.resolveCounter % 1e3;\n          await this.resolveStories(u.data, t, `${p}`);\n        }\n        return t.version === \"published\" && e != \"/cdn/spaces/me\" && await o.set(r, u), u.data.cv && t.token && (t.version === \"draft\" && m[t.token] != u.data.cv && await this.flushCache(), m[t.token] = t.cv ? t.cv : u.data.cv), n(u);\n      } catch (c) {\n        if (c.response && c.status === 429 && (s = s ? s + 1 : 0, s < this.maxRetries))\n          return console.log(`Hit rate limit. Retrying in ${s} seconds.`), await this.helpers.delay(1e3 * s), this.cacheResponse(e, t, s).then(n).catch(l);\n        l(c);\n      }\n    });\n  }\n  throttledRequest(e, t, s) {\n    return this.client[e](t, s);\n  }\n  cacheVersions() {\n    return m;\n  }\n  cacheVersion() {\n    return m[this.accessToken];\n  }\n  setCacheVersion(e) {\n    this.accessToken && (m[this.accessToken] = e);\n  }\n  cacheProvider() {\n    switch (this.cache.type) {\n      case \"memory\":\n        return {\n          get(e) {\n            return Promise.resolve(b[e]);\n          },\n          getAll() {\n            return Promise.resolve(b);\n          },\n          set(e, t) {\n            return b[e] = t, Promise.resolve(void 0);\n          },\n          flush() {\n            return b = {}, Promise.resolve(void 0);\n          }\n        };\n      case \"custom\":\n        if (this.cache.custom)\n          return this.cache.custom;\n      default:\n        return {\n          get() {\n            return Promise.resolve();\n          },\n          getAll() {\n            return Promise.resolve(void 0);\n          },\n          set() {\n            return Promise.resolve(void 0);\n          },\n          flush() {\n            return Promise.resolve(void 0);\n          }\n        };\n    }\n  }\n  async flushCache() {\n    return await this.cacheProvider().flush(), this;\n  }\n}\nconst xe = (i = {}) => {\n  const { apiOptions: e } = i;\n  if (!e.accessToken) {\n    console.error(\n      \"You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication\"\n    );\n    return;\n  }\n  return { storyblokApi: new ve(e) };\n}, we = (i) => {\n  if (typeof i != \"object\" || typeof i._editable > \"u\")\n    return {};\n  try {\n    const e = JSON.parse(\n      i._editable.replace(/^<!--#storyblok#/, \"\").replace(/-->$/, \"\")\n    );\n    return e ? {\n      \"data-blok-c\": JSON.stringify(e),\n      \"data-blok-uid\": e.id + \"-\" + e.uid\n    } : {};\n  } catch {\n    return {};\n  }\n};\nlet T, O = \"https://app.storyblok.com/f/storyblok-v2-latest.js\";\nconst $e = (i, e, t = {}) => {\n  var s;\n  const r = !(typeof window > \"u\") && typeof window.storyblokRegisterEvent < \"u\", o = +new URL((s = window.location) == null ? void 0 : s.href).searchParams.get(\n    \"_storyblok\"\n  ) === i;\n  if (!(!r || !o)) {\n    if (!i) {\n      console.warn(\"Story ID is not defined. Please provide a valid ID.\");\n      return;\n    }\n    window.storyblokRegisterEvent(() => {\n      new window.StoryblokBridge(t).on([\"input\", \"published\", \"change\"], (n) => {\n        n.action === \"input\" && n.story.id === i ? e(n.story) : (n.action === \"change\" || n.action === \"published\") && n.storyId === i && window.location.reload();\n      });\n    });\n  }\n}, Re = (i = {}) => {\n  var e, t;\n  const {\n    bridge: s,\n    accessToken: r,\n    use: o = [],\n    apiOptions: n = {},\n    richText: l = {},\n    bridgeUrl: a\n  } = i;\n  n.accessToken = n.accessToken || r;\n  const c = { bridge: s, apiOptions: n };\n  let u = {};\n  o.forEach((g) => {\n    u = { ...u, ...g(c) };\n  }), a && (O = a);\n  const p = !(typeof window > \"u\") && ((t = (e = window.location) == null ? void 0 : e.search) == null ? void 0 : t.includes(\"_storyblok_tk\"));\n  return s !== !1 && p && H(O), T = new v(l.schema), l.resolver && I(T, l.resolver), u;\n}, I = (i, e) => {\n  i.addNode(\"blok\", (t) => {\n    let s = \"\";\n    return t.attrs.body.forEach((r) => {\n      s += e(r.component, r);\n    }), {\n      html: s\n    };\n  });\n}, _e = (i) => !i || !(i != null && i.content.some((e) => e.content || e.type === \"blok\" || e.type === \"horizontal_rule\")), Ce = (i, e, t) => {\n  let s = t || T;\n  if (!s) {\n    console.error(\n      \"Please initialize the Storyblok SDK before calling the renderRichText function\"\n    );\n    return;\n  }\n  return _e(i) ? \"\" : (e && (s = new v(e.schema), e.resolver && I(s, e.resolver)), s.render(i));\n}, Te = /* @__PURE__ */ A({\n  __name: \"StoryblokComponent\",\n  props: {\n    blok: {}\n  },\n  setup(i, { expose: e }) {\n    const t = i, s = _();\n    e({\n      value: s\n    });\n    const r = typeof $(t.blok.component) != \"string\", o = N(\"VueSDKOptions\"), n = _(t.blok.component);\n    return r || (o.enableFallbackComponent ? (n.value = o.customFallbackComponent ?? \"FallbackComponent\", typeof $(n.value) == \"string\" && console.error(\n      `Is the Fallback component \"${n.value}\" registered properly?`\n    )) : console.error(\n      `Component could not be found for blok \"${t.blok.component}\"! Is it defined in main.ts as \"app.component(\"${t.blok.component}\", ${t.blok.component});\"?`\n    )), (l, a) => (L(), M($(n.value), F({\n      ref_key: \"blokRef\",\n      ref: s\n    }, { ...l.$props, ...l.$attrs }), null, 16));\n  }\n}), Se = {\n  beforeMount(i, e) {\n    if (e.value) {\n      const t = we(e.value);\n      Object.keys(t).length > 0 && (i.setAttribute(\"data-blok-c\", t[\"data-blok-c\"]), i.setAttribute(\"data-blok-uid\", t[\"data-blok-uid\"]), i.classList.add(\"storyblok__outline\"));\n    }\n  }\n}, E = (i) => {\n  console.error(`You can't use ${i} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.\n    `);\n};\nlet y = null;\nconst Pe = () => (y || E(\"useStoryblokApi\"), y), Oe = async (i, e = {}, t = {}) => {\n  const s = _(null);\n  if (t.resolveRelations = t.resolveRelations ?? e.resolve_relations, t.resolveLinks = t.resolveLinks ?? e.resolve_links, z(() => {\n    s.value && s.value.id && $e(\n      s.value.id,\n      (r) => s.value = r,\n      t\n    );\n  }), y) {\n    const { data: r } = await y.get(\n      `cdn/stories/${i}`,\n      e\n    );\n    s.value = r.story;\n  } else\n    E(\"useStoryblok\");\n  return s;\n}, Ie = {\n  install(i, e = {}) {\n    i.directive(\"editable\", Se), i.component(\"StoryblokComponent\", Te), e.enableFallbackComponent && !e.customFallbackComponent && i.component(\n      \"FallbackComponent\",\n      U(() => import(\"./FallbackComponent-hOszcW1L.mjs\"))\n    );\n    const { storyblokApi: t } = Re(e);\n    y = t, i.provide(\"VueSDKOptions\", e);\n  }\n};\nexport {\n  v as RichTextResolver,\n  ye as RichTextSchema,\n  Te as StoryblokComponent,\n  Ie as StoryblokVue,\n  xe as apiPlugin,\n  Ce as renderRichText,\n  Oe as useStoryblok,\n  Pe as useStoryblokApi,\n  $e as useStoryblokBridge\n};\n",
      "start": 1710364424090,
      "end": 1710364424575,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1710364424575,
      "end": 1710364424575,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1710364424576,
      "end": 1710364424576,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "result": "import { __vitePreload } from \"\u0000vite/preload-helper.js\";import { defineComponent as A, ref as _, resolveDynamicComponent as $, inject as N, openBlock as L, createBlock as M, mergeProps as F, onMounted as z, defineAsyncComponent as U } from \"vue\";\nlet j = !1;\nconst x = [], H = (i) => new Promise((e, t) => {\n  if (typeof window > \"u\" || (window.storyblokRegisterEvent = (r) => {\n    if (window.location === window.parent.location) {\n      console.warn(\"You are not in Draft Mode or in the Visual Editor.\");\n      return;\n    }\n    j ? r() : x.push(r);\n  }, document.getElementById(\"storyblok-javascript-bridge\")))\n    return;\n  const s = document.createElement(\"script\");\n  s.async = !0, s.src = i, s.id = \"storyblok-javascript-bridge\", s.onerror = (r) => t(r), s.onload = (r) => {\n    x.forEach((o) => o()), j = !0, e(r);\n  }, document.getElementsByTagName(\"head\")[0].appendChild(s);\n});\nvar q = Object.defineProperty, V = (i, e, t) => e in i ? q(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t, h = (i, e, t) => (V(i, typeof e != \"symbol\" ? e + \"\" : e, t), t);\nfunction C(i) {\n  return !(i !== i || i === 1 / 0 || i === -1 / 0);\n}\nfunction D(i, e, t) {\n  if (!C(e))\n    throw new TypeError(\"Expected `limit` to be a finite number\");\n  if (!C(t))\n    throw new TypeError(\"Expected `interval` to be a finite number\");\n  const s = [];\n  let r = [], o = 0;\n  const n = function() {\n    o++;\n    const a = setTimeout(function() {\n      o--, s.length > 0 && n(), r = r.filter(function(u) {\n        return u !== a;\n      });\n    }, t);\n    r.indexOf(a) < 0 && r.push(a);\n    const c = s.shift();\n    c.resolve(i.apply(c.self, c.args));\n  }, l = function(...a) {\n    const c = this;\n    return new Promise(function(u, p) {\n      s.push({\n        resolve: u,\n        reject: p,\n        args: a,\n        self: c\n      }), o < e && n();\n    });\n  };\n  return l.abort = function() {\n    r.forEach(clearTimeout), r = [], s.forEach(function(a) {\n      a.reject(function() {\n        Error.call(this, \"Throttled function aborted\"), this.name = \"AbortError\";\n      });\n    }), s.length = 0;\n  }, l;\n}\nclass k {\n  constructor() {\n    h(this, \"isCDNUrl\", (e = \"\") => e.indexOf(\"/cdn/\") > -1), h(this, \"getOptionsPage\", (e, t = 25, s = 1) => ({\n      ...e,\n      per_page: t,\n      page: s\n    })), h(this, \"delay\", (e) => new Promise((t) => setTimeout(t, e))), h(this, \"arrayFrom\", (e = 0, t) => [...Array(e)].map(t)), h(this, \"range\", (e = 0, t = e) => {\n      const s = Math.abs(t - e) || 0, r = e < t ? 1 : -1;\n      return this.arrayFrom(s, (o, n) => n * r + e);\n    }), h(this, \"asyncMap\", async (e, t) => Promise.all(e.map(t))), h(this, \"flatMap\", (e = [], t) => e.map(t).reduce((s, r) => [...s, ...r], [])), h(this, \"escapeHTML\", function(e) {\n      const t = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n      }, s = /[&<>\"']/g, r = RegExp(s.source);\n      return e && r.test(e) ? e.replace(s, (o) => t[o]) : e;\n    });\n  }\n  /**\n   * @method stringify\n   * @param  {Object} params\n   * @param  {String} prefix\n   * @param  {Boolean} isArray\n   * @return {String} Stringified object\n   */\n  stringify(e, t, s) {\n    const r = [];\n    for (const o in e) {\n      if (!Object.prototype.hasOwnProperty.call(e, o))\n        continue;\n      const n = e[o], l = s ? \"\" : encodeURIComponent(o);\n      let a;\n      typeof n == \"object\" ? a = this.stringify(\n        n,\n        t ? t + encodeURIComponent(\"[\" + l + \"]\") : l,\n        Array.isArray(n)\n      ) : a = (t ? t + encodeURIComponent(\"[\" + l + \"]\") : l) + \"=\" + encodeURIComponent(n), r.push(a);\n    }\n    return r.join(\"&\");\n  }\n  /**\n   * @method getRegionURL\n   * @param  {String} regionCode region code, could be eu, us, cn, ap or ca\n   * @return {String} The base URL of the region\n   */\n  getRegionURL(e) {\n    const t = \"api.storyblok.com\", s = \"api-us.storyblok.com\", r = \"app.storyblokchina.cn\", o = \"api-ap.storyblok.com\", n = \"api-ca.storyblok.com\";\n    switch (e) {\n      case \"us\":\n        return s;\n      case \"cn\":\n        return r;\n      case \"ap\":\n        return o;\n      case \"ca\":\n        return n;\n      default:\n        return t;\n    }\n  }\n}\nconst B = function(i, e) {\n  const t = {};\n  for (const s in i) {\n    const r = i[s];\n    e.indexOf(s) > -1 && r !== null && (t[s] = r);\n  }\n  return t;\n}, J = (i) => i === \"email\", K = () => ({\n  singleTag: \"hr\"\n}), Y = () => ({\n  tag: \"blockquote\"\n}), W = () => ({\n  tag: \"ul\"\n}), G = (i) => ({\n  tag: [\n    \"pre\",\n    {\n      tag: \"code\",\n      attrs: i.attrs\n    }\n  ]\n}), Q = () => ({\n  singleTag: \"br\"\n}), X = (i) => ({\n  tag: `h${i.attrs.level}`\n}), Z = (i) => ({\n  singleTag: [\n    {\n      tag: \"img\",\n      attrs: B(i.attrs, [\"src\", \"alt\", \"title\"])\n    }\n  ]\n}), ee = () => ({\n  tag: \"li\"\n}), te = () => ({\n  tag: \"ol\"\n}), se = () => ({\n  tag: \"p\"\n}), re = (i) => ({\n  tag: [\n    {\n      tag: \"span\",\n      attrs: {\n        \"data-type\": \"emoji\",\n        \"data-name\": i.attrs.name,\n        emoji: i.attrs.emoji\n      }\n    }\n  ]\n}), oe = () => ({\n  tag: \"b\"\n}), ie = () => ({\n  tag: \"s\"\n}), ne = () => ({\n  tag: \"u\"\n}), ae = () => ({\n  tag: \"strong\"\n}), le = () => ({\n  tag: \"code\"\n}), ce = () => ({\n  tag: \"i\"\n}), he = (i) => {\n  if (!i.attrs)\n    return {\n      tag: \"\"\n    };\n  const e = new k().escapeHTML, t = { ...i.attrs }, { linktype: s = \"url\" } = i.attrs;\n  if (delete t.linktype, t.href && (t.href = e(i.attrs.href || \"\")), J(s) && (t.href = `mailto:${t.href}`), t.anchor && (t.href = `${t.href}#${t.anchor}`, delete t.anchor), t.custom) {\n    for (const r in t.custom)\n      t[r] = t.custom[r];\n    delete t.custom;\n  }\n  return {\n    tag: [\n      {\n        tag: \"a\",\n        attrs: t\n      }\n    ]\n  };\n}, ue = (i) => ({\n  tag: [\n    {\n      tag: \"span\",\n      attrs: i.attrs\n    }\n  ]\n}), pe = () => ({\n  tag: \"sub\"\n}), de = () => ({\n  tag: \"sup\"\n}), ge = (i) => ({\n  tag: [\n    {\n      tag: \"span\",\n      attrs: i.attrs\n    }\n  ]\n}), fe = (i) => {\n  var e;\n  return (e = i.attrs) != null && e.color ? {\n    tag: [\n      {\n        tag: \"span\",\n        attrs: {\n          style: `background-color:${i.attrs.color};`\n        }\n      }\n    ]\n  } : {\n    tag: \"\"\n  };\n}, me = (i) => {\n  var e;\n  return (e = i.attrs) != null && e.color ? {\n    tag: [\n      {\n        tag: \"span\",\n        attrs: {\n          style: `color:${i.attrs.color}`\n        }\n      }\n    ]\n  } : {\n    tag: \"\"\n  };\n}, ye = {\n  nodes: {\n    horizontal_rule: K,\n    blockquote: Y,\n    bullet_list: W,\n    code_block: G,\n    hard_break: Q,\n    heading: X,\n    image: Z,\n    list_item: ee,\n    ordered_list: te,\n    paragraph: se,\n    emoji: re\n  },\n  marks: {\n    bold: oe,\n    strike: ie,\n    underline: ne,\n    strong: ae,\n    code: le,\n    italic: ce,\n    link: he,\n    styled: ue,\n    subscript: pe,\n    superscript: de,\n    anchor: ge,\n    highlight: fe,\n    textStyle: me\n  }\n}, be = function(i) {\n  const e = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n  }, t = /[&<>\"']/g, s = RegExp(t.source);\n  return i && s.test(i) ? i.replace(t, (r) => e[r]) : i;\n};\nclass v {\n  constructor(e) {\n    h(this, \"marks\"), h(this, \"nodes\"), e || (e = ye), this.marks = e.marks || [], this.nodes = e.nodes || [];\n  }\n  addNode(e, t) {\n    this.nodes[e] = t;\n  }\n  addMark(e, t) {\n    this.marks[e] = t;\n  }\n  render(e, t = { optimizeImages: !1 }) {\n    if (e && e.content && Array.isArray(e.content)) {\n      let s = \"\";\n      return e.content.forEach((r) => {\n        s += this.renderNode(r);\n      }), t.optimizeImages ? this.optimizeImages(s, t.optimizeImages) : s;\n    }\n    return console.warn(\n      `The render method must receive an Object with a \"content\" field.\n\t\t\tThe \"content\" field must be an array of nodes as the type ISbRichtext.\n\t\t\tISbRichtext:\n\t\t\t\tcontent?: ISbRichtext[]\n\t\t\t\tmarks?: ISbRichtext[]\n\t\t\t\tattrs?: any\n\t\t\t\ttext?: string\n\t\t\t\ttype: string\n\t\t\t\t\n\t\t\t\tExample:\n\t\t\t\t{\n\t\t\t\t\tcontent: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontent: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttext: 'Hello World',\n\t\t\t\t\t\t\t\t\ttype: 'text'\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\ttype: 'paragraph'\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\ttype: 'doc'\n\t\t\t\t}`\n    ), \"\";\n  }\n  optimizeImages(e, t) {\n    let s = 0, r = 0, o = \"\", n = \"\";\n    typeof t != \"boolean\" && (typeof t.width == \"number\" && t.width > 0 && (o += `width=\"${t.width}\" `, s = t.width), typeof t.height == \"number\" && t.height > 0 && (o += `height=\"${t.height}\" `, r = t.height), (t.loading === \"lazy\" || t.loading === \"eager\") && (o += `loading=\"${t.loading}\" `), typeof t.class == \"string\" && t.class.length > 0 && (o += `class=\"${t.class}\" `), t.filters && (typeof t.filters.blur == \"number\" && t.filters.blur >= 0 && t.filters.blur <= 100 && (n += `:blur(${t.filters.blur})`), typeof t.filters.brightness == \"number\" && t.filters.brightness >= -100 && t.filters.brightness <= 100 && (n += `:brightness(${t.filters.brightness})`), t.filters.fill && (t.filters.fill.match(/[0-9A-Fa-f]{6}/g) || t.filters.fill === \"transparent\") && (n += `:fill(${t.filters.fill})`), t.filters.format && [\"webp\", \"png\", \"jpeg\"].includes(t.filters.format) && (n += `:format(${t.filters.format})`), typeof t.filters.grayscale == \"boolean\" && t.filters.grayscale && (n += \":grayscale()\"), typeof t.filters.quality == \"number\" && t.filters.quality >= 0 && t.filters.quality <= 100 && (n += `:quality(${t.filters.quality})`), t.filters.rotate && [90, 180, 270].includes(t.filters.rotate) && (n += `:rotate(${t.filters.rotate})`), n.length > 0 && (n = \"/filters\" + n))), o.length > 0 && (e = e.replace(/<img/g, `<img ${o.trim()}`));\n    const l = s > 0 || r > 0 || n.length > 0 ? `${s}x${r}${n}` : \"\";\n    return e = e.replace(\n      /a.storyblok.com\\/f\\/(\\d+)\\/([^.]+)\\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g,\n      `a.storyblok.com/f/$1/$2.$3/m/${l}`\n    ), typeof t != \"boolean\" && (t.sizes || t.srcset) && (e = e.replace(/<img.*?src=[\"|'](.*?)[\"|']/g, (a) => {\n      var c, u;\n      const p = a.match(\n        /a.storyblok.com\\/f\\/(\\d+)\\/([^.]+)\\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g\n      );\n      if (p && p.length > 0) {\n        const g = {\n          srcset: (c = t.srcset) == null ? void 0 : c.map((d) => {\n            if (typeof d == \"number\")\n              return `//${p}/m/${d}x0${n} ${d}w`;\n            if (typeof d == \"object\" && d.length === 2) {\n              let w = 0, S = 0;\n              return typeof d[0] == \"number\" && (w = d[0]), typeof d[1] == \"number\" && (S = d[1]), `//${p}/m/${w}x${S}${n} ${w}w`;\n            }\n          }).join(\", \"),\n          sizes: (u = t.sizes) == null ? void 0 : u.map((d) => d).join(\", \")\n        };\n        let f = \"\";\n        return g.srcset && (f += `srcset=\"${g.srcset}\" `), g.sizes && (f += `sizes=\"${g.sizes}\" `), a.replace(/<img/g, `<img ${f.trim()}`);\n      }\n      return a;\n    })), e;\n  }\n  renderNode(e) {\n    const t = [];\n    e.marks && e.marks.forEach((r) => {\n      const o = this.getMatchingMark(r);\n      o && o.tag !== \"\" && t.push(this.renderOpeningTag(o.tag));\n    });\n    const s = this.getMatchingNode(e);\n    return s && s.tag && t.push(this.renderOpeningTag(s.tag)), e.content ? e.content.forEach((r) => {\n      t.push(this.renderNode(r));\n    }) : e.text ? t.push(be(e.text)) : s && s.singleTag ? t.push(this.renderTag(s.singleTag, \" /\")) : s && s.html ? t.push(s.html) : e.type === \"emoji\" && t.push(this.renderEmoji(e)), s && s.tag && t.push(this.renderClosingTag(s.tag)), e.marks && e.marks.slice(0).reverse().forEach((r) => {\n      const o = this.getMatchingMark(r);\n      o && o.tag !== \"\" && t.push(this.renderClosingTag(o.tag));\n    }), t.join(\"\");\n  }\n  renderTag(e, t) {\n    return e.constructor === String ? `<${e}${t}>` : e.map((s) => {\n      if (s.constructor === String)\n        return `<${s}${t}>`;\n      {\n        let r = `<${s.tag}`;\n        if (s.attrs)\n          for (const o in s.attrs) {\n            const n = s.attrs[o];\n            n !== null && (r += ` ${o}=\"${n}\"`);\n          }\n        return `${r}${t}>`;\n      }\n    }).join(\"\");\n  }\n  renderOpeningTag(e) {\n    return this.renderTag(e, \"\");\n  }\n  renderClosingTag(e) {\n    return e.constructor === String ? `</${e}>` : e.slice(0).reverse().map((t) => t.constructor === String ? `</${t}>` : `</${t.tag}>`).join(\"\");\n  }\n  getMatchingNode(e) {\n    const t = this.nodes[e.type];\n    if (typeof t == \"function\")\n      return t(e);\n  }\n  getMatchingMark(e) {\n    const t = this.marks[e.type];\n    if (typeof t == \"function\")\n      return t(e);\n  }\n  renderEmoji(e) {\n    if (e.attrs.emoji)\n      return e.attrs.emoji;\n    const t = [\n      {\n        tag: \"img\",\n        attrs: {\n          src: e.attrs.fallbackImage,\n          draggable: \"false\",\n          loading: \"lazy\",\n          align: \"absmiddle\"\n        }\n      }\n    ];\n    return this.renderTag(t, \" /\");\n  }\n}\nclass ke {\n  constructor(e) {\n    h(this, \"baseURL\"), h(this, \"timeout\"), h(this, \"headers\"), h(this, \"responseInterceptor\"), h(this, \"fetch\"), h(this, \"ejectInterceptor\"), h(this, \"url\"), h(this, \"parameters\"), h(this, \"fetchOptions\"), this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = \"\", this.parameters = {}, this.fetchOptions = {};\n  }\n  /**\n   *\n   * @param url string\n   * @param params ISbStoriesParams\n   * @returns Promise<ISbResponse | Error>\n   */\n  get(e, t) {\n    return this.url = e, this.parameters = t, this._methodHandler(\"get\");\n  }\n  post(e, t) {\n    return this.url = e, this.parameters = t, this._methodHandler(\"post\");\n  }\n  put(e, t) {\n    return this.url = e, this.parameters = t, this._methodHandler(\"put\");\n  }\n  delete(e, t) {\n    return this.url = e, this.parameters = t, this._methodHandler(\"delete\");\n  }\n  async _responseHandler(e) {\n    const t = [], s = {\n      data: {},\n      headers: {},\n      status: 0,\n      statusText: \"\"\n    };\n    e.status !== 204 && await e.json().then((r) => {\n      s.data = r;\n    });\n    for (const r of e.headers.entries())\n      t[r[0]] = r[1];\n    return s.headers = { ...t }, s.status = e.status, s.statusText = e.statusText, s;\n  }\n  async _methodHandler(e) {\n    let t = `${this.baseURL}${this.url}`, s = null;\n    if (e === \"get\") {\n      const a = new k();\n      t = `${this.baseURL}${this.url}?${a.stringify(\n        this.parameters\n      )}`;\n    } else\n      s = JSON.stringify(this.parameters);\n    const r = new URL(t), o = new AbortController(), { signal: n } = o;\n    let l;\n    this.timeout && (l = setTimeout(() => o.abort(), this.timeout));\n    try {\n      const a = await this.fetch(`${r}`, {\n        method: e,\n        headers: this.headers,\n        body: s,\n        signal: n,\n        ...this.fetchOptions\n      });\n      this.timeout && clearTimeout(l);\n      const c = await this._responseHandler(\n        a\n      );\n      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(c)) : this._statusHandler(c);\n    } catch (a) {\n      return {\n        message: a\n      };\n    }\n  }\n  setFetchOptions(e = {}) {\n    Object.keys(e).length > 0 && \"method\" in e && delete e.method, this.fetchOptions = { ...e };\n  }\n  eject() {\n    this.ejectInterceptor = !0;\n  }\n  _statusHandler(e) {\n    const t = /20[0-6]/g;\n    return new Promise((s, r) => {\n      if (t.test(`${e.status}`))\n        return s(e);\n      const o = {\n        message: e.statusText,\n        status: e.status,\n        response: Array.isArray(e.data) ? e.data[0] : e.data.error || e.data.slug\n      };\n      r(o);\n    });\n  }\n}\nconst P = \"SB-Agent\", R = {\n  defaultAgentName: \"SB-JS-CLIENT\",\n  defaultAgentVersion: \"SB-Agent-Version\",\n  packageVersion: \"6.0.0\"\n};\nlet b = {};\nconst m = {};\nclass ve {\n  /**\n   *\n   * @param config ISbConfig interface\n   * @param endpoint string, optional\n   */\n  constructor(e, t) {\n    h(this, \"client\"), h(this, \"maxRetries\"), h(this, \"throttle\"), h(this, \"accessToken\"), h(this, \"cache\"), h(this, \"helpers\"), h(this, \"resolveCounter\"), h(this, \"relations\"), h(this, \"links\"), h(this, \"richTextResolver\"), h(this, \"resolveNestedRelations\"), h(this, \"stringifiedStoriesCache\");\n    let s = e.endpoint || t;\n    if (!s) {\n      const n = new k().getRegionURL, l = e.https === !1 ? \"http\" : \"https\";\n      e.oauthToken ? s = `${l}://${n(e.region)}/v1` : s = `${l}://${n(e.region)}/v2`;\n    }\n    const r = new Headers();\n    if (r.set(\"Content-Type\", \"application/json\"), r.set(\"Accept\", \"application/json\"), e.headers)\n      for (const n in e.headers)\n        r.set(n, e.headers[n]);\n    r.has(P) || (r.set(P, R.defaultAgentName), r.set(\n      R.defaultAgentVersion,\n      R.packageVersion\n    ));\n    let o = 5;\n    e.oauthToken && (r.set(\"Authorization\", e.oauthToken), o = 3), e.rateLimit && (o = e.rateLimit), e.richTextSchema ? this.richTextResolver = new v(e.richTextSchema) : this.richTextResolver = new v(), e.componentResolver && this.setComponentResolver(e.componentResolver), this.maxRetries = e.maxRetries || 5, this.throttle = D(this.throttledRequest, o, 1e3), this.accessToken = e.accessToken || \"\", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: \"manual\" }, this.helpers = new k(), this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.client = new ke({\n      baseURL: s,\n      timeout: e.timeout || 0,\n      headers: r,\n      responseInterceptor: e.responseInterceptor,\n      fetch: e.fetch\n    });\n  }\n  setComponentResolver(e) {\n    this.richTextResolver.addNode(\"blok\", (t) => {\n      let s = \"\";\n      return t.attrs.body && t.attrs.body.forEach((r) => {\n        s += e(r.component, r);\n      }), {\n        html: s\n      };\n    });\n  }\n  parseParams(e) {\n    return e.token || (e.token = this.getToken()), e.cv || (e.cv = m[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(\",\")), typeof e.resolve_relations < \"u\" && (e.resolve_level = 2), e;\n  }\n  factoryParamOptions(e, t) {\n    return this.helpers.isCDNUrl(e) ? this.parseParams(t) : t;\n  }\n  makeRequest(e, t, s, r) {\n    const o = this.factoryParamOptions(\n      e,\n      this.helpers.getOptionsPage(t, s, r)\n    );\n    return this.cacheResponse(e, o);\n  }\n  get(e, t, s) {\n    t || (t = {});\n    const r = `/${e}`, o = this.factoryParamOptions(r, t);\n    return this.client.setFetchOptions(s), this.cacheResponse(r, o);\n  }\n  async getAll(e, t, s, r) {\n    const o = (t == null ? void 0 : t.per_page) || 25, n = `/${e}`, l = n.split(\"/\"), a = s || l[l.length - 1], c = 1, u = await this.makeRequest(n, t, o, c), p = u.total ? Math.ceil(u.total / o) : 1;\n    this.client.setFetchOptions(r);\n    const g = await this.helpers.asyncMap(\n      this.helpers.range(c, p),\n      (f) => this.makeRequest(n, t, o, f + 1)\n    );\n    return this.helpers.flatMap(\n      [u, ...g],\n      (f) => Object.values(f.data[a])\n    );\n  }\n  post(e, t, s) {\n    const r = `/${e}`;\n    return this.client.setFetchOptions(s), Promise.resolve(this.throttle(\"post\", r, t));\n  }\n  put(e, t, s) {\n    const r = `/${e}`;\n    return this.client.setFetchOptions(s), Promise.resolve(this.throttle(\"put\", r, t));\n  }\n  delete(e, t, s) {\n    const r = `/${e}`;\n    return this.client.setFetchOptions(s), Promise.resolve(this.throttle(\"delete\", r, t));\n  }\n  getStories(e, t) {\n    return this.client.setFetchOptions(t), this._addResolveLevel(e), this.get(\"cdn/stories\", e);\n  }\n  getStory(e, t, s) {\n    return this.client.setFetchOptions(s), this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t);\n  }\n  getToken() {\n    return this.accessToken;\n  }\n  ejectInterceptor() {\n    this.client.eject();\n  }\n  _addResolveLevel(e) {\n    typeof e.resolve_relations < \"u\" && (e.resolve_level = 2);\n  }\n  _cleanCopy(e) {\n    return JSON.parse(JSON.stringify(e));\n  }\n  _insertLinks(e, t, s) {\n    const r = e[t];\n    r && r.fieldtype == \"multilink\" && r.linktype == \"story\" && typeof r.id == \"string\" && this.links[s][r.id] ? r.story = this._cleanCopy(this.links[s][r.id]) : r && r.linktype === \"story\" && typeof r.uuid == \"string\" && this.links[s][r.uuid] && (r.story = this._cleanCopy(this.links[s][r.uuid]));\n  }\n  /**\n   *\n   * @param resolveId A counter number as a string\n   * @param uuid The uuid of the story\n   * @returns string | object\n   */\n  getStoryReference(e, t) {\n    return this.relations[e][t] ? (this.stringifiedStoriesCache[t] || (this.stringifiedStoriesCache[t] = JSON.stringify(\n      this.relations[e][t]\n    )), JSON.parse(this.stringifiedStoriesCache[t])) : t;\n  }\n  _insertRelations(e, t, s, r) {\n    s.indexOf(`${e.component}.${t}`) > -1 && (typeof e[t] == \"string\" ? e[t] = this.getStoryReference(r, e[t]) : Array.isArray(e[t]) && (e[t] = e[t].map((o) => this.getStoryReference(r, o)).filter(Boolean)));\n  }\n  iterateTree(e, t, s) {\n    const r = (o) => {\n      if (o != null) {\n        if (o.constructor === Array)\n          for (let n = 0; n < o.length; n++)\n            r(o[n]);\n        else if (o.constructor === Object) {\n          if (o._stopResolving)\n            return;\n          for (const n in o)\n            (o.component && o._uid || o.type === \"link\") && (this._insertRelations(\n              o,\n              n,\n              t,\n              s\n            ), this._insertLinks(\n              o,\n              n,\n              s\n            )), r(o[n]);\n        }\n      }\n    };\n    r(e.content);\n  }\n  async resolveLinks(e, t, s) {\n    let r = [];\n    if (e.link_uuids) {\n      const o = e.link_uuids.length, n = [], l = 50;\n      for (let a = 0; a < o; a += l) {\n        const c = Math.min(o, a + l);\n        n.push(e.link_uuids.slice(a, c));\n      }\n      for (let a = 0; a < n.length; a++)\n        (await this.getStories({\n          per_page: l,\n          language: t.language,\n          version: t.version,\n          by_uuids: n[a].join(\",\")\n        })).data.stories.forEach(\n          (c) => {\n            r.push(c);\n          }\n        );\n    } else\n      r = e.links;\n    r.forEach((o) => {\n      this.links[s][o.uuid] = {\n        ...o,\n        _stopResolving: !0\n      };\n    });\n  }\n  async resolveRelations(e, t, s) {\n    let r = [];\n    if (e.rel_uuids) {\n      const o = e.rel_uuids.length, n = [], l = 50;\n      for (let a = 0; a < o; a += l) {\n        const c = Math.min(o, a + l);\n        n.push(e.rel_uuids.slice(a, c));\n      }\n      for (let a = 0; a < n.length; a++)\n        (await this.getStories({\n          per_page: l,\n          language: t.language,\n          version: t.version,\n          by_uuids: n[a].join(\",\"),\n          excluding_fields: t.excluding_fields\n        })).data.stories.forEach((c) => {\n          r.push(c);\n        });\n    } else\n      r = e.rels;\n    r && r.length > 0 && r.forEach((o) => {\n      this.relations[s][o.uuid] = {\n        ...o,\n        _stopResolving: !0\n      };\n    });\n  }\n  /**\n   *\n   * @param responseData\n   * @param params\n   * @param resolveId\n   * @description Resolves the relations and links of the stories\n   * @returns Promise<void>\n   *\n   */\n  async resolveStories(e, t, s) {\n    var r, o;\n    let n = [];\n    if (this.links[s] = {}, this.relations[s] = {}, typeof t.resolve_relations < \"u\" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == \"string\" && (n = t.resolve_relations.split(\",\")), await this.resolveRelations(e, t, s)), t.resolve_links && [\"1\", \"story\", \"url\", \"link\"].indexOf(t.resolve_links) > -1 && ((r = e.links) != null && r.length || (o = e.link_uuids) != null && o.length) && await this.resolveLinks(e, t, s), this.resolveNestedRelations)\n      for (const l in this.relations[s])\n        this.iterateTree(\n          this.relations[s][l],\n          n,\n          s\n        );\n    e.story ? this.iterateTree(e.story, n, s) : e.stories.forEach((l) => {\n      this.iterateTree(l, n, s);\n    }), this.stringifiedStoriesCache = {}, delete this.links[s], delete this.relations[s];\n  }\n  async cacheResponse(e, t, s) {\n    (typeof s > \"u\" || !s) && (s = 0);\n    const r = this.helpers.stringify({ url: e, params: t }), o = this.cacheProvider();\n    if (this.cache.clear === \"auto\" && t.version === \"draft\" && await this.flushCache(), t.version === \"published\" && e != \"/cdn/spaces/me\") {\n      const n = await o.get(r);\n      if (n)\n        return Promise.resolve(n);\n    }\n    return new Promise(async (n, l) => {\n      var a;\n      try {\n        const c = await this.throttle(\"get\", e, t);\n        if (c.status !== 200)\n          return l(c);\n        let u = { data: c.data, headers: c.headers };\n        if ((a = c.headers) != null && a[\"per-page\"] && (u = Object.assign({}, u, {\n          perPage: c.headers[\"per-page\"] ? parseInt(c.headers[\"per-page\"]) : 0,\n          total: c.headers[\"per-page\"] ? parseInt(c.headers.total) : 0\n        })), u.data.story || u.data.stories) {\n          const p = this.resolveCounter = ++this.resolveCounter % 1e3;\n          await this.resolveStories(u.data, t, `${p}`);\n        }\n        return t.version === \"published\" && e != \"/cdn/spaces/me\" && await o.set(r, u), u.data.cv && t.token && (t.version === \"draft\" && m[t.token] != u.data.cv && await this.flushCache(), m[t.token] = t.cv ? t.cv : u.data.cv), n(u);\n      } catch (c) {\n        if (c.response && c.status === 429 && (s = s ? s + 1 : 0, s < this.maxRetries))\n          return console.log(`Hit rate limit. Retrying in ${s} seconds.`), await this.helpers.delay(1e3 * s), this.cacheResponse(e, t, s).then(n).catch(l);\n        l(c);\n      }\n    });\n  }\n  throttledRequest(e, t, s) {\n    return this.client[e](t, s);\n  }\n  cacheVersions() {\n    return m;\n  }\n  cacheVersion() {\n    return m[this.accessToken];\n  }\n  setCacheVersion(e) {\n    this.accessToken && (m[this.accessToken] = e);\n  }\n  cacheProvider() {\n    switch (this.cache.type) {\n      case \"memory\":\n        return {\n          get(e) {\n            return Promise.resolve(b[e]);\n          },\n          getAll() {\n            return Promise.resolve(b);\n          },\n          set(e, t) {\n            return b[e] = t, Promise.resolve(void 0);\n          },\n          flush() {\n            return b = {}, Promise.resolve(void 0);\n          }\n        };\n      case \"custom\":\n        if (this.cache.custom)\n          return this.cache.custom;\n      default:\n        return {\n          get() {\n            return Promise.resolve();\n          },\n          getAll() {\n            return Promise.resolve(void 0);\n          },\n          set() {\n            return Promise.resolve(void 0);\n          },\n          flush() {\n            return Promise.resolve(void 0);\n          }\n        };\n    }\n  }\n  async flushCache() {\n    return await this.cacheProvider().flush(), this;\n  }\n}\nconst xe = (i = {}) => {\n  const { apiOptions: e } = i;\n  if (!e.accessToken) {\n    console.error(\n      \"You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication\"\n    );\n    return;\n  }\n  return { storyblokApi: new ve(e) };\n}, we = (i) => {\n  if (typeof i != \"object\" || typeof i._editable > \"u\")\n    return {};\n  try {\n    const e = JSON.parse(\n      i._editable.replace(/^<!--#storyblok#/, \"\").replace(/-->$/, \"\")\n    );\n    return e ? {\n      \"data-blok-c\": JSON.stringify(e),\n      \"data-blok-uid\": e.id + \"-\" + e.uid\n    } : {};\n  } catch {\n    return {};\n  }\n};\nlet T, O = \"https://app.storyblok.com/f/storyblok-v2-latest.js\";\nconst $e = (i, e, t = {}) => {\n  var s;\n  const r = !(typeof window > \"u\") && typeof window.storyblokRegisterEvent < \"u\", o = +new URL((s = window.location) == null ? void 0 : s.href).searchParams.get(\n    \"_storyblok\"\n  ) === i;\n  if (!(!r || !o)) {\n    if (!i) {\n      console.warn(\"Story ID is not defined. Please provide a valid ID.\");\n      return;\n    }\n    window.storyblokRegisterEvent(() => {\n      new window.StoryblokBridge(t).on([\"input\", \"published\", \"change\"], (n) => {\n        n.action === \"input\" && n.story.id === i ? e(n.story) : (n.action === \"change\" || n.action === \"published\") && n.storyId === i && window.location.reload();\n      });\n    });\n  }\n}, Re = (i = {}) => {\n  var e, t;\n  const {\n    bridge: s,\n    accessToken: r,\n    use: o = [],\n    apiOptions: n = {},\n    richText: l = {},\n    bridgeUrl: a\n  } = i;\n  n.accessToken = n.accessToken || r;\n  const c = { bridge: s, apiOptions: n };\n  let u = {};\n  o.forEach((g) => {\n    u = { ...u, ...g(c) };\n  }), a && (O = a);\n  const p = !(typeof window > \"u\") && ((t = (e = window.location) == null ? void 0 : e.search) == null ? void 0 : t.includes(\"_storyblok_tk\"));\n  return s !== !1 && p && H(O), T = new v(l.schema), l.resolver && I(T, l.resolver), u;\n}, I = (i, e) => {\n  i.addNode(\"blok\", (t) => {\n    let s = \"\";\n    return t.attrs.body.forEach((r) => {\n      s += e(r.component, r);\n    }), {\n      html: s\n    };\n  });\n}, _e = (i) => !i || !(i != null && i.content.some((e) => e.content || e.type === \"blok\" || e.type === \"horizontal_rule\")), Ce = (i, e, t) => {\n  let s = t || T;\n  if (!s) {\n    console.error(\n      \"Please initialize the Storyblok SDK before calling the renderRichText function\"\n    );\n    return;\n  }\n  return _e(i) ? \"\" : (e && (s = new v(e.schema), e.resolver && I(s, e.resolver)), s.render(i));\n}, Te = /* @__PURE__ */ A({\n  __name: \"StoryblokComponent\",\n  props: {\n    blok: {}\n  },\n  setup(i, { expose: e }) {\n    const t = i, s = _();\n    e({\n      value: s\n    });\n    const r = typeof $(t.blok.component) != \"string\", o = N(\"VueSDKOptions\"), n = _(t.blok.component);\n    return r || (o.enableFallbackComponent ? (n.value = o.customFallbackComponent ?? \"FallbackComponent\", typeof $(n.value) == \"string\" && console.error(\n      `Is the Fallback component \"${n.value}\" registered properly?`\n    )) : console.error(\n      `Component could not be found for blok \"${t.blok.component}\"! Is it defined in main.ts as \"app.component(\"${t.blok.component}\", ${t.blok.component});\"?`\n    )), (l, a) => (L(), M($(n.value), F({\n      ref_key: \"blokRef\",\n      ref: s\n    }, { ...l.$props, ...l.$attrs }), null, 16));\n  }\n}), Se = {\n  beforeMount(i, e) {\n    if (e.value) {\n      const t = we(e.value);\n      Object.keys(t).length > 0 && (i.setAttribute(\"data-blok-c\", t[\"data-blok-c\"]), i.setAttribute(\"data-blok-uid\", t[\"data-blok-uid\"]), i.classList.add(\"storyblok__outline\"));\n    }\n  }\n}, E = (i) => {\n  console.error(`You can't use ${i} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.\n    `);\n};\nlet y = null;\nconst Pe = () => (y || E(\"useStoryblokApi\"), y), Oe = async (i, e = {}, t = {}) => {\n  const s = _(null);\n  if (t.resolveRelations = t.resolveRelations ?? e.resolve_relations, t.resolveLinks = t.resolveLinks ?? e.resolve_links, z(() => {\n    s.value && s.value.id && $e(\n      s.value.id,\n      (r) => s.value = r,\n      t\n    );\n  }), y) {\n    const { data: r } = await y.get(\n      `cdn/stories/${i}`,\n      e\n    );\n    s.value = r.story;\n  } else\n    E(\"useStoryblok\");\n  return s;\n}, Ie = {\n  install(i, e = {}) {\n    i.directive(\"editable\", Se), i.component(\"StoryblokComponent\", Te), e.enableFallbackComponent && !e.customFallbackComponent && i.component(\n      \"FallbackComponent\",\n      U(() => __vitePreload(() => import(\"./FallbackComponent-hOszcW1L.mjs\"),__VITE_IS_MODERN__?\"__VITE_PRELOAD__\":void 0,import.meta.url))\n    );\n    const { storyblokApi: t } = Re(e);\n    y = t, i.provide(\"VueSDKOptions\", e);\n  }\n};\nexport {\n  v as RichTextResolver,\n  ye as RichTextSchema,\n  Te as StoryblokComponent,\n  Ie as StoryblokVue,\n  xe as apiPlugin,\n  Ce as renderRichText,\n  Oe as useStoryblok,\n  Pe as useStoryblokApi,\n  $e as useStoryblokBridge\n};\n",
      "start": 1710364424576,
      "end": 1710364424577,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:reporter",
      "start": 1710364424577,
      "end": 1710364424577,
      "order": "normal"
    }
  ]
}
